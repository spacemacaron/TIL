
### 알고리즘

효용 : 알고리즘을 공부하면 코드를 효율적으로 만들 수있다. 

개발자가 개발하는 과정
	1. 프로그램이 돌아가는 수준.
	2. 코딩 다했다!
	3. 버그 없다!
	4. 코드를 정리한다! 
	(관리와 협업이 편리해졌습니다!)

… 코드가 효율적이고 속도가 빠르면 안 되는 걸까?
	Ø 이쯤 되면 필요해짐

알고리즘 : 컴퓨터에게 내리는 지시 사항의 나열 
대단하게 생각하지 말자. 라면 끓이는 과정도 알고리즘,
등교 준비하는 것도 알고리즘.

그런데, 등교 준비하기 알고리즘 중에서 효율성이 더 좋은 것도 있다. 그런 알고리즘을 사용해서 등교 준비를 하는 사람이면 학교를 더 빨리 갈 수 있을 것. 컴퓨터도 똑같다 

다양한 알고리즘 편
실생활 예 

목적지까지 최대한 빨리 가는 방법 (지도 앱) > 패스 파인더 알고리즘
이미지를 최대한 덜 손상하면서도 용량을 효율적으로 줄일 수 있는 알고리즘 > 압축 알고리즘, 흔히 보는 png jpg 

데이터를 효율적으로 보관하고 찾기 위한 자료구조
자료구조의 자료 = 데이터. 
니꼬쌤은 데이터가 oil(원유) 라고 생각한다는군
요즘 핫한 인공지능 데이터가 엄청나게 필요하다, 데이터가 없으면 아무것도 할 수 없다… 무료 서비스 하면서 데이터를 긁어모으는 개발자를 보자… 와 역시 뭔가 공짜일 땐 내가 돈이었던 것이다.

프론트엔드 개발자라면 백엔드서 내려받은 JSON씨 데이터로 그것을 보기 좋게 화면에 띄우는 역할을 할 것이다.
그런데 데이터가 마구잡이로 보관되어있다면 어떨까? 데이터를 찾는데 시간이 욜라리 걸린다면? 그래서 자료구조 공부해야된다. 찾기 좋게 제대로 보관하는 게 좋지 않을까?

자료구조 방식

데이터를 작은 것부터 큰 순서로 정리 (데이터 크기)
이름표를 붙여서 정리하기 (인덱스 기준)
데이터가 들어오는 순서대로 정리(생성 시간)

왜 이렇게 다양할까? 프로그램의 목적이 다양하기 때문이다.
(검색, 시간..크기.. 등등) 


배열

시간 복잡도 = 작업속도 
프로그램의 작업 속도가 얼마나 빠른가?
준비 시-작! 처럼 실제 시간을 재지 않음. 작업이 얼마나 많은 단계를 거치는지를 측정. 

예를 들어 어떤 작업을 하는데 어떤 코드는 5단계, 어떤 코드는 20단계가 필요하다면 5단계가 빠르다고 함.

메모리 간단 설명
메모리 : 컴퓨터의 기억 공간 
휘발성의 유무로 휘발성/비휘발성 메모리로 구분

비휘발성 메모리 : 하드 드라이브 C드라이브 D드라이브
휘발성: RAM 

램이 속도가 빠른 이유?
램은 주소지가 적힌 빡스를 많이 있는 창고라고 생각하면 됨. 박스에는 데이터를 1개씩 저장할 수 있고, 박스에는 각각 주소가 있다. 그러면 박스에 보관된 데이터를 빠르게 찾을 수 있음. 램한테 4번 박스에 있는 데이터좀 이라고 하면 해당 박스에 있는 데이터를 보면 됨. 없으면 다뒤져야 되니까 느림.

다시 배열로 돌아와서 배열을 만들 때는 길이를 컴퓨터에 알려줘야 함 

길이가 4인 배열을 램에 할당좀!

을 번역하면

박스 4개를 붙여서 창고에 자리좀!


몇 번째 데이터를 보라고 하는 거기 때문에 작업 속도는 빠르다. 배열을 읽는 속도는 1단계.

배열을 검색하는 원리와 속도

N번째 박스좀 찾아죵! 대신에

과자좀 찾아죵! 

이라고 하면 어느 박스에 있는지 모르기 때문에 시간이 많이 걸림. (선형 검색으로 한정했을 때)


배열에 데이터를 삽입하는 원리와 속도

	1. 마지막에 추가한다. (그냥 끝에 추가)
	2. 배열 중간에 추가한다( 배추 당근을 뒤로 옮기는 작업 필요)
	3. 맨 앞에 넣는다 (완전 최악 다 옮겨야됨 ㅡㅡ)
	4. 배열에 데이터가 꽉 차있다..
	(더 큰 배열을 새로 만들고 > 이전 배열을 복사 > 옮김 > 새 데이터 추가)
	
삭제 : 삽입과 비슷 (맨앞 데이터 삭제가 젤 힘듦)


알고리즘의 속도를 표현하는 방법 : Big - O
선형 알고리즘 : 배열을 앞에서 한땀 한땀 검색 
배열크키가 커지면 > 검색시간도 정비례 증가
배열의 길이가 N , 검색횟수는 N
이때 시간복잡도가 O(N) 이과놈들이 말하기 편할라고 만든거같음. 선형 검색 알고리즘의 시간 복잡도는 O(N)이다 라고 함.

Def print_first(arr):
	Print(arr[0])
	
시간복잡도는 O(1)이다 = 상수시간(constant time) 내에 실행된다. 
상수시간: 이미 실행 횟수가 고정으로 정해진 것 
(위 코드에서 함수는 딱 한 번 실행하고 끝나므로)

Def print_first(arr):
	Print(arr[0])
	Print(arr[0])

시간복잡도가 O(2) 라고 생각하셨나요? 유감이다
O(1)이다. Big-O는 실행 단계에 영향을 주는 요소만 보기 때문이다. 배열 길이와 상관없이 늘 실행횟수가 같으니까 1

Def print_all(arr):
	For n in arr:
	Print(n)

이놈은 배열의 길이에 따라 실행 시간이 달라짐
배열 길이가 10이면 10 100이면 100, 그래서
시간복잡도는 O(N)

이차시간(quadratic time) : 중첩 반복문이 있을 때 발생

Def print_twice(arr):
	For n in arr:
		For x in arr:
			Print(x, n)
			
알러지가 생길 것 같은 2단 코드다 으아악
배열 길이가 100이면 10000번 돌려야하지 너무 끔찎하군
작업 속도는 제곱배로 느려진다. 
O(N제곱) 

나머지는 스스로 공부하라는 니꼬쌤의 친절함에 감탄하고 말았다 크..자기주도적 학습인가 뭔가 하는건가

선형 검색 알고리즘
-선형이든 이진이든 둘 다 검색 관련 작업을 수행함

암튼 선형 검색
가장 자연스러운 검색 방법
만약 1~10까지 배열에서 7을 찾는다고 치면 1부터 쭉 보면 그만. 최악의 시나리오는 찾는 숫자가 맨 끝에 있을 때. Y=x그래프

이진 검색 알고리즘

배열의 크기가 크면 이놈이 더 좋다. 데이터 정렬이 끝난 배열에서만 사용 가능. 특정 알고리즘은 특정 자료구조에서만 사용할 수 있다. 

정렬이 끝난 배열 = 리터럴리 데이터가 순서대로 정렬된 상태

중앙값을 기준으로 왼쪽 오른쪽 왓다리 갔다리 하면서 찾음
(반 짤라서 버리고 없으면 또 반갈해서 찾는 그 그거..)

1~10까지의 배열이 있다고 치면 9를 찾는데 
선형은 9번
이진은 3번만에 끗

Y = log x 
데이터가 많아져도 검색 시간에 비해 그렇게 많이 필요하지 않음, 


정렬 알고리즘 

초보수준 히히
	1. 왼/오만 보면서 정렬한다 버블정렬
그렇게 좋진 않고 많이 안 씀. 하지만 공부용으론 제격이죠.
2칸짜리 창문을 놓고 오른쪽으로 1칸씩 밀면서 왼/오 비교하는 방식으로 정렬. 한 사이클이 끝나면 가장 큰 수가 마지막에 위치할거다. 궁금하면 손으로 해보기
시간복잡도는 N* N

	2. 하나를 콕 찝는다 선택정렬
가장 작은 데이터 혹은 가장 큰 데이터의 위치를 따로 기억하는 방식으로 작업을 진행
시간복잡도는 N * N 그래도 버블보다는 효율적이다
자리를 바꾸는 연산은 사이클당 1번이기 때문에.

	3. 앞에 있는 데이터를 보면서 배치하는 삽입 정렬
앞에 있는 데이터를 보면서 배치하는 특징이 있음
1번쨰 데이터부터 비교. 포인트는 교환이 아니라 밀어 넣는다는 거다. 밀어넣기 작업이 끝나면 사이클이 끝 
시간복잡도는 N * N, 선택 버블보다 속도는 빠름

슬슬 이거 믿어도 되는거냐? 싶을것이다.
시간 복잡도가 같다고 한 건 시간 복잡도를 단순하게 측정했을 때 그렇다는 뜻이다. 알고리즘은 초기 데이터 상태에 따라 처리 속도가 달라진다는 특징도 있다. 기계적으로 측정한 시간 복잡도는 같아도 평균적으로 빠른 알고리즘은 있을 수 있음. 

정렬은 검색으로 해결 가능하니 외우지 말어라 중생아

자료구조 계속

규칙 개념의 자료구조 

추상 자료구조 (ADT)

개발자의 상상 속 개념. 문법으로 구현된 것이 아님. 배열은 자료구조지만 문법으로도 사용할 수 있게 되어있다. 
Nico_array = ["사과", "배", "김치"]
처럼.
근데 큐나 스택은 문법이 따로 없음. 기존 프로그래밍 언어의 문법으로 데이터를 저장할 때 어떤 규칙만 부여하기만 하면 되기 때문이다. 배열에 큐의 규칙을 부여하면 그 배열은 큐라고 할 수 있다. 

스택이나 큐는 결국 어떤 배열에 어떤 규칙을 합친 거다.
팬케이크를 차곡차곡 쌓는다고 생각해보자. 그러면 최근에 구운 따끈한 놈이 맨 위에 있겠지? 그리고 먹을 때는 위부터 냠냠. 스택도 그렇다. 배열이 수직으로 쌓여있다고 생각하고 맨 위를 정하는 것임. 값을 추가/삭제할 때 맨 위라고 정해놓은 부분에서만 그 작업을 해야한다. 

스택의 규칙 1. 위에서 데이터를 쌓는다
	   규칙 2. 위에서부터 데이터 뺀다
LIFO

규칙만 지키면, 뭘로 규현해도 좋다.

큐의 규칙 1. 위로 데이터를 쌓는다.
	규칙 2. 아레부터 데이터를 뺀다.
FIFO
아주 상식적이다. 버스정류장 줄 서있는 것과 같다. 오래 기다린 사람 먼저 타십시요.

언제 스택이나 큐를 사용하는가?
웹 브라우저 뒤로가기 버튼 -스택
컨트롤 제트 -스택
쇼핑몰 주문처리 - 큐



	
ref- 5분에 읽는 IT 잡학사전 